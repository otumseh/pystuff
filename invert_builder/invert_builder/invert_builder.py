# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SSI_Inverts C:/Users/Cary/AppData/Roaming/QGIS/QGIS3/profiles/default/python/plugins 
                                 A QGIS plugin
 This plug-in attempts to build inverts for Surveying Solutions Inc
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-11-19                           Revision date 1217_2026
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Cary Hutchinson Surveying Solutions Inc
        email                : chutchinson@ssi-mi.com
 ***************************************************************************/"""

import math
import os, shutil
import time
import shelve

#from google.cloud import storage
from pathlib import Path

from qgis.core import QgsVectorLayer, QgsField, QgsProject, QgsFeature, QgsPoint, QgsGeometry, QgsPointXY
from PyQt5 import QtWidgets
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, QVariant
from PyQt5.QtGui import QIcon, QDoubleValidator, QIntValidator
from PyQt5.QtWidgets import QAction, QFileDialog, QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .invert_builder_dialog import SSI_InvertsDialog

class SSI_Inverts:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.db_LocalName = self.plugin_dir   #default database dir
        self.db_file = "mydb.db"
        self.db_is_open = False
        
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SSI_Inverts_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

         # Declare instance attributes
        material_type = ["RCP","CLAY","CMP","PVC","CPP","CLV","BOLTED DOWN","CPD","EDGE DRAIN","METAL","RECESSED", "STEEL PIPE","TOP OF NUT","WELDED SHUT","UNK"]
        lid_type = ["Round", "Square", "2Square"]
        struct_type = ["CB", "CBR","STMH","SMH","WMH","MH","WSO","ELEC","TELE","UNK"]
        #pipe_dia = ["6" ,"8" ,"10" ,"12" , "14" , "15", "16" , "18" , "20" ,"24" ,"26" ,"30" ,"36" ,"48" ,"60" ,"72" ,"84"]   
        self.job_Number = "NULL"
        self.pipe_layer = "NULL"
        self.struct_layer = "NULL"
        self.pipe_descr_list = []
        self.pipe_conn_list = []
        
        self.currStruct = {'CODE': 'CB','NUMBER':'0000', 'JOBNUM':'690716', 'YOURNAME':'Lebowski', 'SUMPDIST': '0.01','UPDATE':'1969_07_16','LID':'RUSTY', 'NOTES':'The only thing new in the world is the history you do not know.'}   
        self.currPipe = {'name':'0000', 'jobnum':'690716', 'yourname':'Lebowski', 'invt_start': '0.01', 'invt_end': '0.01','material':'WMD','UPDATE':'1969_07_16', 
                          'start':'UNKN', 'end':'UNKN', 'status':'unkn', 'diameter':'un', 'ellipwidth':'0.0', 'stub_ang':'NULL', 'drain':'NULL'}
        
        self.home = os.getenv("HOME")
        self.local_dir = self.home
        self.Struct_local_file = self.home
        self.pipe_local_file = self.home
        self.local_struct_lyr = "STRUCL"
        self.local_pipe_lyr = "PIPEL"

        self.vpnpath = self.home

        self.actions = []
        self.menu = self.tr(u'&SSI Structure')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'SSI_Inverts')
        self.toolbar.setObjectName(u'SSI_Inverts')
        
        # Create the dialog (after translation) and keep reference
        self.dlg = SSI_InvertsDialog()
        self.dlg.combo_StructType.addItems(struct_type)  #set the cobbo box text lists
        self.dlg.combo_Lid.addItems(lid_type)
        self.dlg.combo_PipeMaterial.addItems(material_type)
        self.dlg.label_Date.setText("Wilson")

        #VALIDATE lineEdits
        int_validatJob = QIntValidator()
        dbl_validator = QDoubleValidator()
        dbl_validatZ = QDoubleValidator(0.0,2500.0,5,None)
        dbl_validatDia = QDoubleValidator(2.0,55.0,3,None)
        dbl_validatDistDwn = QDoubleValidator(2.0,65.0,3,None)
        
        #self.dlg.lineEdit_JobNum.setValidator(int_validatJob)
        
        self.dlg.lineEdit_StructX.setValidator(dbl_validator)
        self.dlg.lineEdit_StructY.setValidator(dbl_validator)
        self.dlg.lineEdit_StructElev.setValidator(dbl_validatZ)
        self.dlg.lineEdit_DistDown.setValidator(dbl_validatDistDwn)
        self.dlg.lineEdit_VertDown.setValidator(dbl_validatDistDwn)
        self.dlg.lineEdit_StubAngle.setValidator(int_validatJob)
        self.dlg.lineEdit_Diameter.setValidator(int_validatJob)
        self.dlg.lineEdit_Ellipse.setValidator(int_validatJob)
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('SSI_Inverts', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToDatabaseMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/invert_builder/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'SSI Structure Creator'),
            callback=self.run,
            parent=self.iface.mainWindow())
        #buttons inside the invert_builder.ui
        self.dlg.pb_NewStructure.clicked.connect(self.new_structure)
        self.dlg.pb_EditStructure.clicked.connect(self.edit_structure)
        self.dlg.pB_AddPipe.clicked.connect(self.add_Pipe)
        #self.dlg.pB_RemovePipe.clicked.connect(self.add_fields)
        
        self.dlg.pb_MakeLocal.clicked.connect(self.create_local)   
        self.dlg.pb_SyncFiles.clicked.connect(self.syncFiles)
        self.dlg.pb_SaveStruct.clicked.connect(self.save_struct)
        self.dlg.pb_ActiveStruct.clicked.connect(self.activestruct)
        self.dlg.pB_SavePipeEdit.clicked.connect(self.savePipeEdit) 
        self.dlg.pb_formatLayers.clicked.connect(self.layer_properties) 
        
        #lineEdits inside the invert_builder.ui
        #self.dlg.lineEdit_JobNum.returnPressed.connect(self.name_check)
        #self.dlg.lineEdit_StructNumb.returnPressed.connect(self.name_check)
        self.dlg.lineEdit_StructNumb.textChanged.connect(self.name_check)
        self.dlg.lineEdit_YourName.returnPressed.connect(self.name_check)
        self.dlg.lineEdit_Connecto.returnPressed.connect(self.checkConnect)

        self.dlg.combo_StructType.activated.connect(self.changeCode)
        self.dlg.combo_Lid.activated.connect(self.changeLid)
        self.dlg.combo_PipeList.activated.connect(self.editPipe)
    
    def edit_structure(self):
        self.name_check()
        edit_struc = self.dlg.label_StructDisp.text()
        if self.struct_layer == "NULL":
            self.popMsg('Select an existing, active feature to populate the form.')
            return
        else:
            struct_layer = QgsProject.instance().mapLayersByName(self.struct_layer)[0]
            struct_data = struct_layer.dataProvider()
            structures = struct_layer.getFeatures()
            struct_exist = bool(False)
            for struct in structures:                
                if edit_struc == struct['NUMBER']:
                    geom = struct.geometry()
                    self.currStruct['CODE'] =  str(struct['CODE'])
                    self.currStruct['NUMBER'] =str(struct['NUMBER'])
                    self.currStruct['JOBNUM'] = struct['JOBNUM']
                    self.currStruct['SUMPDIST'] = str(struct['SUMPDIST'])
                    self.currStruct['UPDATE'] = str(struct['UPDATE'])
                    self.currStruct['LID'] = str(struct['LID'])
                    self.currStruct['NOTES'] = str(struct['NOTES'])
                    struct_exist = True
                
            if struct_exist == False:
                self.popMsg('Structure not found')
                return
            
        
        selecX = geom.get().x()
        selecY = geom.get().y()
        selecZ = geom.get().z()  #remember to geom.get().setZ(xxxx) on SAVE
        
        
        self.dlg.label_StructType.setText(str(self.currStruct['CODE'])) #label_StructType
        self.dlg.lineEdit_StructX.setText(str(selecX))
        self.dlg.lineEdit_StructY.setText(str(selecY))
        self.dlg.lineEdit_StructElev.setText(str(selecZ))
        self.dlg.lineEdit_StructNumb.setText(str(self.currStruct['NUMBER']))
        self.dlg.label_StructDisp.setText(str(self.currStruct['NUMBER']))
        self.dlg.lineEdit_DistDown.setText(str(self.currStruct['SUMPDIST']))
        self.dlg.label_Date.setText(str(self.currStruct['UPDATE']))
        self.dlg.label_LidType.setText(str(self.currStruct['LID']))
        self.dlg.textEdit_Notes.setText(str(self.currStruct['NOTES']))

        self.get_conn_pipes()
        centPoint = QgsPointXY(selecX , selecY)
        self.iface.mapCanvas().setCenter(centPoint)
        struct_layer.triggerRepaint()
        
        '''The following code will center on the point in the structure selected.
        
        cent = iface.mapCanvas().center()

        centPoint = QgsPointXY(26134100.0,643792.0)
        point2 = QgsPoint(26132801.0,645013.0)
        rectan = QgsRectangle(26132801.0,643792.0, 26134100.0,645013.0)
        iface.mapCanvas().setExtent(rectan)
        iface.mapCanvas().setCenter(point1)
        '''
    def new_structure(self):
        self.name_check()
        new_struc = self.dlg.label_StructDisp.text()
        if self.struct_layer == "NULL":
            self.popMsg('Select an existing, active feature to populate the form.')
            return
        else:
            struct_layer = QgsProject.instance().mapLayersByName(self.struct_layer)[0]
            struct_data = struct_layer.dataProvider()
            structures = struct_layer.getFeatures()
            
            for struct in structures:
                
                if new_struc == struct['NUMBER']:
                    self.popMsg("You already have that one  " + new_struc)
                    return
                elif new_struc in "STRUCTURE":
                    self.popMsg("Name invalid " + new_struc)
                    return
               
            
            struct_layer.startEditing()
            this_struct = QgsFeature()
            fields = struct_layer.fields()
            this_struct.setFields(fields)
            
            self.currStruct['CODE'] = self.dlg.label_StructType.text() #Code is Structure Type
            self.currStruct['NUMBER'] = self.dlg.label_StructDisp.text()
            self.currStruct['JOBNUM'] = self.dlg.label_JobDisp.text()
            self.currStruct['YOURNAME'] = self.dlg.lineEdit_YourName.text()
            self.currStruct['SUMPDIST'] = self.dlg.lineEdit_DistDown.text()
                    
            self.currStruct['UPDATE'] = str(time.time())
            self.currStruct['LID'] = self.dlg.combo_Lid.currentText() 
            self.currStruct['NOTES'] = self.dlg.textEdit_Notes.toPlainText()

            date_now = date_now = time.localtime(time.time())
            now_time = (str(date_now[0]) + "_" + str(date_now[1]) + "_" + str(date_now[2]) + "_" + str(date_now[3]) + "_" + str(date_now[4]))
            self.dlg.label_Date.setText(now_time)

            this_struct['NUMBER'] = self.currStruct['NUMBER']
            this_struct['CODE'] = self.currStruct['CODE']
            this_struct['JOBNUM'] = self.currStruct['JOBNUM']
            this_struct['SUMPDIST'] = self.currStruct['SUMPDIST']
            this_struct['UPDATE'] = self.currStruct['UPDATE']
            this_struct['YOURNAME'] = self.currStruct['YOURNAME']
            this_struct['LID'] = self.currStruct['LID']
            this_struct['NOTES'] = self.currStruct['NOTES']
            try:                       
                x_pos = float(self.dlg.lineEdit_StructX.text())  #change the geometry of the feature also.
                y_pos = float(self.dlg.lineEdit_StructY.text())
                z_pos = float(self.dlg.lineEdit_StructElev.text()) 
            except:
                self.popMsg('Check your X, Y and Elevation')
                return

            self.clear_pipeSide()
            this_struct.setGeometry(QgsGeometry(QgsPoint(x_pos, y_pos, z_pos)))

            struct_data.addFeatures([this_struct])    
            struct_layer.updateExtents()              
            struct_layer.commitChanges()
            struct_layer.triggerRepaint()

    def create_local(self):
        """Open the XXXX.db file locally in directory - should contain the job number""" 
        self.local_dir = QFileDialog.getExistingDirectory(None, "Open a folder", self.local_dir, QFileDialog.ShowDirsOnly)
        file_ini = str(self.currStruct['JOBNUM']) + "_ini"
        self.vpnpath = "W:/SSI_Structure/"+ self.currStruct['JOBNUM'] 
        path_absolute = QgsProject.instance().readPath("./")
        pathstring = str(path_absolute).split('/')
        if pathstring[0] != 'W:':
            self.vpnpath = path_absolute
            self.popMsg('You are already are working local')
            self.popMsg('check for W drive')
            return
        else:        
            self.popMsg(file_ini)
            self.popMsg('vpnPath' + self.vpnpath)
            
            src_files = os.listdir(self.vpnpath)
                        
            if os.path.isfile(self.local_dir + "/" + file_ini + '.dat'):                
                with shelve.open(self.local_dir + "/" + file_ini) as init:
                    self.popMsg(init['sync'])
                    if init['sync'] == 'YES':
                        for file_name in src_files:
                            full_file_name = os.path.join(self.vpnpath, file_name)
                            if (os.path.isfile(full_file_name)):
                                shutil.copy(full_file_name, self.local_dir)
                        init['path'] = str(self.local_dir + "/" + file_ini)
                        init['jonnum'] = self.currStruct['JOBNUM']
                        init['descp'] = 'Get this description in here somehow' 
                        init['update'] = str(time.time())
                        init['sync']  ='NO' 
                    else:
                        self.popMsg('local files have not been synced')   
                        return       

            else:
                self.popMsg(self.local_dir + "/" + file_ini)
                for file_name in src_files:
                            full_file_name = os.path.join(self.vpnpath, file_name)
                            if (os.path.isfile(full_file_name)):
                                shutil.copy(full_file_name, self.local_dir)
                with shelve.open(self.local_dir + "/" + file_ini) as init:
                    init['path'] = str(self.local_dir + "/" + file_ini)
                    init['jonnum'] = self.currStruct['JOBNUM']
                    init['descp'] = 'Get this description in here somehow'
                    init['vpnpath'] = self.vpnpath
                    init['update'] = str(time.time())
                    init['sync']  ='NO' 
            
    #THINGS TO DO - VERIFY JOBNUM_PIPES LAYER, GENERATE NEW GEOMETRY.   
    # 
    def syncFiles(self):
        if self.struct_layer == "NULL":
            self.popMsg('Select a structure from the structure')
            return

        self.local_dir = QFileDialog.getExistingDirectory(None, "Select LOCAL folder", self.local_dir, QFileDialog.ShowDirsOnly)
        #Download to Local directory then sync
                
        path_absolute = QgsProject.instance().readPath("./")
        pathstring = str(path_absolute).split('/')
        if pathstring[0] != 'W:':
            self.vpnpath = path_absolute
            self.popMsg('You are already are working local')
            self.popMsg('check for W drive project - Sync from there')
            return
        else:
            openfile = QFileDialog.getOpenFileName(None, "Pick Structure Shape File", self.local_dir, "Shape File (*.shp)")           
            self.dlg.label_Local_shp.setText(openfile[0])
            self.project_file = QgsProject.instance().fileName()
            self.Struct_local_file = str(Path(openfile[0]))  
            self.popMsg("Pick a file for the PIPE sync on the local directory")

            pipefile = QFileDialog.getOpenFileName(None, "Pick PIPES File", self.local_dir, "Shape File (*.shp)")     
            
            self.pipe_local_file = str(Path(pipefile[0])) 

            #Check to make sure this is a STRUCTURE FILE *****************************************************************************************************
            '''push it to a layer and compare the sync_structures'''
            self.sync_structures()
            self.sync_pipes()
    
    def sync_pipes(self):
        
        pipe_layer  = QgsProject.instance().mapLayersByName(self.pipe_layer)[0]
        pipe_layer.setLabelsEnabled(True)
        pipe_layer.triggerRepaint()
        
        if not pipe_layer.isValid():
            self.popMsg('Structure Layer is not valid')
            return
        layer_localpipe = self.iface.addVectorLayer(self.pipe_local_file , "PIPESL", "ogr")
        if not layer_localpipe.isValid():
            self.popMsg('Local Structure Layer is not valid')
            return
         
        self.local_pipe_lyr = str(layer_localpipe.name())
        pipes = pipe_layer.getFeatures()
        data_prov_pipe = pipe_layer.dataProvider()
        
        data_prov_local = layer_localpipe.dataProvider()
        mas_updated = int(0)
        mas_added = int(0)
        local_updated = int(0)
        local_added = int(0)
        ident_items = int(0)
        pipe_list = []
        local_list = []
        layer_localpipe.startEditing()
        pipe_layer.startEditing()
        for feature in  pipes:   #look for updates both directions.
            pipe_list.append(feature['name'])
            local_pipe = layer_localpipe.getFeatures()
            for local in local_pipe:                
                if feature['name'] == local['name']:  
                    print(feature['name'] + " is equal to " + local['name']) #Temp                  
                    if feature['update'] > local['update']:
                        attr = feature.attributes()
                        local.setAttributes(attr)
                        geom = feature.geometry()
                        local.setGeometry(geom)
                        layer_localpipe.updateFeature(local)    
                        local_updated += 1                  
                        
                    elif feature['update'] < local['update']:
                        print('updating Network') #Temp
                        attr = local.attributes()
                        feature.setAttributes(attr)
                        geom2 = local.geometry()
                        feature.setGeometry(geom2)  
                        mas_updated += 1  
                        pipe_layer.updateFeature(feature)  

                    #Update feature in layer
                    else:
                        ident_items += 1  
                else:
                    print(feature['name'] + " is != " + local['name']) #Temp 

        initial_pipe = len(pipe_list)
        self.popMsg("initial " + str(initial_pipe) + " identical  " + str(ident_items) + " Changed local =" + str(local_updated) + " Network " + str(mas_updated))

        local_pipe = layer_localpipe.getFeatures()
        for local in local_pipe:
            local_list.append(local['name'])
            if local['name'] not in pipe_list:
                data_prov_pipe.addFeatures([local])  
        self.popMsg(str(len(local_list))) #Temp
        pipe_layer.updateExtents()                
        pipe_layer.commitChanges()

        pipes = pipe_layer.getFeatures()
        for pipe in pipes:           
            if pipe['name'] not in local_list:
                data_prov_local.addFeatures([local]) 

        layer_localpipe.updateExtents() 
        layer_localpipe.commitChanges() 
        QgsProject.instance().removeMapLayers( [layer_localpipe.id()])                           
            
    def sync_structures(self):
        
        struct_layer  = QgsProject.instance().mapLayersByName(self.struct_layer)[0]
        struct_layer.setLabelsEnabled(True)
        struct_layer.triggerRepaint()
        
        if not struct_layer.isValid():
            self.popMsg('Structure Layer is not valid')
            return
        layer_localstruct = self.iface.addVectorLayer(self.Struct_local_file, "STRUCL", "ogr")
        if not layer_localstruct.isValid():
            self.popMsg('Local Structure Layer is not valid')
            return
         
        self.local_struct_lyr = str(layer_localstruct.name())
        structures = struct_layer.getFeatures()
        data_prov_struct = struct_layer.dataProvider()
        
        data_prov_local = layer_localstruct.dataProvider()
        mas_updated = int(0)
        mas_added = int(0)
        local_updated = int(0)
        local_added = int(0)
        ident_items = int(0)
        structure_list = []
        local_list = []
        layer_localstruct.startEditing()
        struct_layer.startEditing()
        for feature in  structures:   #look for updates both directions.
            structure_list.append(feature['NUMBER'])
            local_struct = layer_localstruct.getFeatures()
            for local in local_struct:
                
                if feature['NUMBER'] == local['NUMBER']:  
                    print(feature['NUMBER'] + " is equal to " + local['NUMBER']) #Temp                  
                    if feature['UPDATE'] > local['UPDATE']:
                        print('updating Local') #Temp
                        local['UPDATE'] = feature['UPDATE']
                        local['CODE'] = feature['CODE']
                        
                        local['JOBNUM'] = feature['JOBNUM']
                        local['YOURNAME'] = feature['YOURNAME']
                        local['SUMPDIST'] = feature['SUMPDIST']
                        local['LID'] = feature['LID']
                        local['NOTES'] = feature['NOTES'] 
                        geom = feature.geometry()
                        local.setGeometry(geom)
                        layer_localstruct.updateFeature(local)    
                        local_updated += 1                  
                        
                    elif feature['UPDATE'] < local['UPDATE']:
                        print('updating Network') #Temp
                        feature['UPDATE'] = local['UPDATE']
                        feature['CODE']   = local['CODE']
                        
                        feature['JOBNUM'] = local['JOBNUM']
                        feature['YOURNAME'] = local['YOURNAME']
                        feature['SUMPDIST'] = local['SUMPDIST']
                        feature['LID'] = local['LID']
                        feature['NOTES'] = local['NOTES']  
                        geom2 = local.geometry()
                        feature.setGeometry(geom2)  
                        mas_updated += 1  
                        struct_layer.updateFeature(feature)  

                    #Update feature in layer
                    else:
                        ident_items += 1  
                else:
                    print(feature['NUMBER'] + " is != " + local['NUMBER']) #Temp 

        initial_struct = len(structure_list)
        self.popMsg("initial " + str(initial_struct) + " identical  " + str(ident_items) + " Changed local =" + str(local_updated) + " Network " + str(mas_updated))

        local_struct = layer_localstruct.getFeatures()
        for local in local_struct:
            local_list.append(local['NUMBER'])
            if local['NUMBER'] not in structure_list:
                data_prov_struct.addFeatures([local])  
        self.popMsg(str(len(local_list))) #Temp
        struct_layer.updateExtents()                
        struct_layer.commitChanges()

        structures = struct_layer.getFeatures()
        for structure in structures:           
            if structure['NUMBER'] not in local_list:
                data_prov_local.addFeatures([local]) 
                

        layer_localstruct.updateExtents() 
        layer_localstruct.commitChanges() 
        #QgsProject.instance().removeMapLayers( [layer_local.id()] )
        file_ini = str(self.currStruct['JOBNUM']) + "_ini"
        with shelve.open(self.local_dir + "/" + file_ini) as init:
                    init['path'] = str(self.local_dir + "/" + file_ini)
                    
                    init['descp'] = 'Get this description in here somehow'
                    init['vpnpath'] = self.vpnpath
                    init['update'] = str(time.time())
                    init['sync']  ='YES' 
        QgsProject.instance().removeMapLayers( [layer_localstruct.id()]) 

    def save_all(self):
        self.save_struct()
        self.savePipeEdit()
    
   
    def editPipe(self):
        
        if self.dlg.combo_PipeList.currentText() not in self.pipe_conn_list:
            self.popMsg('Pipe item not in list')
            return
        else:
            self.currPipe['name'] = str(self.dlg.combo_PipeList.currentText())
            

            pipe_lyr = QgsProject.instance().mapLayersByName(self.pipe_layer)[0]
            if not pipe_lyr.isValid():
                self.popMsg('Layer is not valid')
    
                return
            pipes = pipe_lyr.getFeatures()
            for pipe in pipes:
                if pipe['name'] == self.currPipe['name']:
                    self.dlg.label_PipeDisp.setText(pipe['name'])
                    self.currPipe['jobnum'] = self.currStruct['JOBNUM']
                    self.currPipe['invt_start'] = pipe['invt_start']
                    self.currPipe['invt_end'] = pipe['invt_end']
                    self.currPipe['material'] = pipe['material']
                    self.currPipe["start"] = pipe['start']
                    self.currPipe["end"] = pipe['end']
                    self.currPipe['status'] = pipe['status']
                    self.currPipe["diameter"] = pipe['diameter']
                    self.currPipe["ellipwidth"] = pipe['ellipwidth']
                    self.currPipe['stub_ang'] = pipe['stub_ang']
                    self.currPipe['drain'] = pipe['drain']
                    geom = pipe.geometry()
                    line = geom.constGet() #line returns a QgsLineString object
                
                    x0 = line.xAt(0) # x value of first vertex
                    y0 = line.yAt(0) # y value of first vertex
                    z0 = line.zAt(0) # z value of first vertex
                    x1 = line.xAt(1) # x value of 2nd vertex
                    y1 = line.yAt(1) # y value of 2nd vertex
                    z1 = line.zAt(1) # z value of 2nd vertex 

                    self.dlg.lineEdit_Diameter.setText(str(pipe['diameter']))
                    self.dlg.lineEdit_Ellipse.setText(str(pipe['ellipwidth']))
                    self.dlg.lineEdit_StubAngle.setText(str(pipe['stub_ang']))
                    self.dlg.label_Drain.setText(str(pipe['drain']))

                    if str(pipe['end']) == self.currStruct['NUMBER']:
                        self.dlg.lineEdit_Connecto.setText(self.currPipe["start"])
                        self.dlg.lineEdit_VertDown.setText(self.currPipe['invt_end'])
                        z_other_end = str(z0)
                        z_this_end = str(z1)
                      
                    else:
                        self.dlg.lineEdit_Connecto.setText(self.currPipe["end"])
                        self.dlg.lineEdit_VertDown.setText(self.currPipe['invt_start'])
                        z_other_end = str(z1)
                        z_this_end = str(z0)
                    #Update elevations Here
                    self.dlg.label_ElevThisEnd.setText(z_this_end)
                    self.dlg.label_ElevOtherEnd.setText(z_other_end)
            self.dlg.label_PipeStatus.setText(self.currPipe["status"])        
                        
                    

    def checkConnect(self):
        '''Scroll through the layers'''
        job_Number = str(self.currStruct["JOBNUM"])
        curr_Struct = str(self.currStruct["NUMBER"])
        self.get_layers()
       
        if curr_Struct == '':
            self.popMsg('Structure is not valid')
            msgBox.exec()
            return
        pipe_name = curr_Struct + "_" + str(self.dlg.lineEdit_Connecto.text())
        self.dlg.label_PipeDisp.setText(pipe_name)
        self.currPipe['name'] = pipe_name
        pipe_lyr = QgsProject.instance().mapLayersByName(self.pipe_layer)[0]
        if not pipe_lyr.isValid():
            self.popMsg('Layer is not valid')
        
            return
        pipes = pipe_lyr.getFeatures()
        self.dlg.combo_PipeList.clear()
        self.dlg.listWidget_PipeDescr.clear()
        self.pipe_conn_list = []
        self.pipe_descr_list = []
        for pipe in pipes:
            if (pipe["start"] == curr_Struct) or (pipe["end"] == curr_Struct):
                self.pipe_conn_list.append(pipe['name'])
                
                pipe_descrp = str(pipe['name']) + "_"+ str(pipe['diameter']) + "_" + str(pipe['material'])
                self.pipe_descr_list.append(pipe_descrp)
        
        self.dlg.combo_PipeList.addItems(self.pipe_conn_list)
        self.dlg.listWidget_PipeDescr.addItems(self.pipe_descr_list)

    def clear_pipeSide(self):
        self.dlg.combo_PipeList.clear()
        self.dlg.listWidget_PipeDescr.clear()
        self.dlg.lineEdit_Diameter.clear()
        self.dlg.lineEdit_VertDown.clear()
        self.dlg.lineEdit_Connecto.clear()
        self.dlg.lineEdit_Ellipse.clear()
        self.dlg.label_ElevOtherEnd.setText('??')
        self.pipe_conn_list = []
        self.pipe_descr_list = []

        #check for PIPES layer
        #check in PIPES layer for start and end with structure NUMBER
        #Create pipe name
    def get_conn_pipes(self):
        self.clear_pipeSide()
        job_Number = str(self.currStruct["JOBNUM"])
        curr_Struct = str(self.currStruct["NUMBER"])
        pipe_lyr = QgsProject.instance().mapLayersByName(self.pipe_layer)[0]
        if not pipe_lyr.isValid():
            self.popMsg('Layer is not valid')
            return
        pipes = pipe_lyr.getFeatures()
        
        for pipe in pipes:
            if (pipe["start"] == curr_Struct) or (pipe["end"] == curr_Struct):
                self.pipe_conn_list.append(pipe['name'])
                
                pipe_descrp = str(pipe['name']) + "_"+ str(pipe['diameter']) + "_" + str(pipe['material'])
                self.pipe_descr_list.append(pipe_descrp)
        
        self.dlg.combo_PipeList.addItems(self.pipe_conn_list)
        self.dlg.listWidget_PipeDescr.addItems(self.pipe_descr_list)
        #self.popMsg('Pipe widget updated')
    
    def set_draintype(self):
        if self.currStruct['CODE'] == 'MH':
            self.currPipe['drain'] = "SSL"
        elif (self.currStruct['CODE'] == 'CB') or (self.currStruct['CODE'] == 'STMH'):
            self.currPipe['drain'] = "SSL"
        else:
            self.currPipe['drain'] = "SAN"
        self.dlg.label_Drain.setText(str(self.currPipe['drain']))
    
    def savePipeEdit(self):

        curr_Struct = str(self.currStruct["NUMBER"])
        connecto = str(self.dlg.lineEdit_Connecto.text())
        self.currPipe['stub_ang'] = self.dlg.lineEdit_StubAngle.text()
        self.set_draintype()


        if self.currStruct['CODE'] == 'MH':
            self.currPipe['drain'] = "SSL"
        elif (self.currStruct['CODE'] == 'CB') or (self.currStruct['CODE'] == 'STMH'):
            self.currPipe['drain'] = "SSL"
        else:
            self.currPipe['drain'] = "SAN"
        self.dlg.label_Drain.setText(str(self.currPipe['drain']))
        

        sump = str(self.currStruct['SUMPDIST'])
        if sump.replace('.','').isdigit():
            pass
        else:
            self.popMsg("Sump distance for structure not saved.")
            return
        
        if 'stub' in connecto.lower():
            if self.dlg.lineEdit_StubAngle.text().isdigit():
                connecto = 'stub'
                pipe_angl = float(self.dlg.lineEdit_StubAngle.text())
            else:
                self.popMsg('Need angle for stub.  (0 to 360) North. no decimal')
                return
                
        else:
            pipe_angl = 360.0
        
        if self.dlg.lineEdit_VertDown.text().isdigit == False:
            
            self.popMsg(str(self.dlg.lineEdit_YourName.text() + ' Input a measurment to the bottom of the pipe first.'))
            return
        elif float(self.dlg.lineEdit_VertDown.text()) > float(self.currStruct['SUMPDIST']):
            self.popMsg(self.dlg.lineEdit_VertDown.text() + ' is lower than the sump floor.')
            return
        elif len(self.dlg.lineEdit_YourName.text()) < 3:
            self.popMsg('Your name is too short')
            return
        else:
            vert_down = float(self.dlg.lineEdit_VertDown.text())

        self.currPipe['yourname'] = self.dlg.lineEdit_YourName.text()
        pipe_lyr = QgsProject.instance().mapLayersByName(self.pipe_layer)[0]
        data_prov_pipe = pipe_lyr.dataProvider()
        struct_layer = QgsProject.instance().mapLayersByName(self.struct_layer)[0]
        if not pipe_lyr.isValid():
            raise Exception('Layer is not valid')

        pipes = pipe_lyr.getFeatures()
        pipe_check = False
        name_check = False
        for pipe in pipes:
            
            if (pipe['start'] == curr_Struct) and (pipe['end'] == connecto):
                pipe_check = True
                if pipe['name'] == self.currPipe['name']:
                    name_check = True

                
            elif (pipe['end'] == curr_Struct) and (pipe['start'] == connecto):
                pipe_check = True
                if pipe['name'] == self.currPipe['name']:
                    name_check = True
               
        if (pipe_check == True) and (name_check == True): 
            self.currPipe['ellipwidth'] = str(self.dlg.lineEdit_Ellipse.text()) 
            self.currPipe['diameter'] = str(self.dlg.lineEdit_Diameter.text())
            self.currPipe['stub_ang'] = str(self.dlg.lineEdit_StubAngle.text())
            self.currPipe['material'] = self.dlg.combo_PipeMaterial.currentText()
            diam = float(self.dlg.lineEdit_Diameter.text())
                    
            pipe_descrp = str(self.currPipe['name']) + "_"+ self.currPipe['diameter'] + " inch " + self.currPipe['material'] + " - Updated"
            x_this = float(self.dlg.lineEdit_StructX.text())
            y_this = float(self.dlg.lineEdit_StructY.text())
            z_cent_pipe = float(self.dlg.lineEdit_StructElev.text()) -vert_down + (diam/24)
            point1 = QgsPoint(x_this, y_this, z_cent_pipe)
            point2 = QgsPoint()
            z_other_end = 0.0
            
            pipes = pipe_lyr.getFeatures()
            pipe_lyr.startEditing()
            for pipe in pipes:
                if pipe['name'] == self.currPipe['name']:
                    
                    pipe_id = pipe.id()
                    #self.popMsg('Pipe stub angle ' + str(self.currPipe['stub_ang'] ))
                    pipe["jobnum"] = self.currPipe['jobnum']                        
                    pipe["material"] = self.currPipe['material']                       
                    pipe["update"] = str(time.time())
                    pipe["yourname"] = self.currPipe['yourname']
                   
                    
                    pipe["diameter"] = self.currPipe['diameter']
                    pipe["ellipwidth"] = self.currPipe['ellipwidth']            
                    pipe['stub_ang'] = self.currPipe['stub_ang'] 
                    pipe['drain'] = self.currPipe['drain'] 
                    
                    geom = pipe.geometry()
                    line = geom.constGet() #line returns a QgsLineString object
                
                    x0 = line.xAt(0) # x value of first vertex
                    y0 = line.yAt(0) # y value of first vertex
                    z0 = line.zAt(0) # z value of first vertex
                    x1 = line.xAt(1) # x value of 2nd vertex
                    y1 = line.yAt(1) # y value of 2nd vertex
                    z1 = line.zAt(1) # z value of 2nd vertex
                    z_this_end = str(z_cent_pipe)
                    z_other_end = str(z1)
                    

                    if (str(pipe['end']) == self.currStruct['NUMBER']) and ('stub' not in pipe['name'] ):
                        pipe['invt_end'] = self.dlg.lineEdit_VertDown.text()
                        self.currPipe['invt_end'] = pipe['invt_end']
                        #geom2 = QgsGeometry.fromPolyline([start_point, point1])
                        point1 = QgsPoint( x0, y0, z0)
                        point2 = QgsPoint( x_this, y_this, z_cent_pipe)
                        z_other_end = str(z0)
                        z_this_end = str(z_cent_pipe)
                        
                    elif (str(pipe['start']) == self.currStruct['NUMBER']) and ('stub' not in pipe['name'] ):
                        pipe['invt_start'] = self.dlg.lineEdit_VertDown.text()
                        self.currPipe['invt_start'] = pipe['invt_start']
                        #geom2 = QgsGeometry.fromPolyline([point1, end_point])
                        point1 = QgsPoint( x_this, y_this, z_cent_pipe)
                        point2 = QgsPoint( x1, y1, z1)
                        z_other_end = str(z1)
                        z_this_end = str(z_cent_pipe)

                    elif (str(pipe['start']) == self.currStruct['NUMBER']) and ('stub' in pipe['name'] ):
                        x_other_end = x_this + (20.5 * math.sin(6.2832 * (pipe_angl/360)))
                        y_other_end = y_this + (20.5 * math.cos(6.2832 * (pipe_angl/360)))
                        point2 = QgsPoint(x_other_end, y_other_end, z_cent_pipe)
                        point1 = QgsPoint( x_this, y_this, z_cent_pipe)
                        #
                        z_other_end = str(z_cent_pipe)
                        z_this_end = str(z_cent_pipe)                   

                    else:
                        self.popMsg('Neither start nor end match this pipe')
                    #Update elevations Here
                    self.dlg.label_ElevThisEnd.setText(z_this_end)
                    self.dlg.label_ElevOtherEnd.setText(z_other_end)
                    
                    
                    if  (float(self.currPipe['invt_start']) > 0.5) and (float(self.currPipe['invt_end']) > 0.5):
                        self.popMsg("ends " + self.currPipe['invt_start'] + "  " + self.currPipe['invt_end'] )
                        self.currPipe['status'] = 'Complete'
                    elif (connecto == 'stub') and (float(self.currPipe['invt_start']) > 0.5): 
                        self.currPipe['status'] = 'Complete'
                        
                    else:
                        self.currPipe['status'] = 'Incomplete'
                        
                        
                    pipe["status"] = self.currPipe['status']

                    #Get both points and see which one is this structures end and update those points only https://gis.stackexchange.com/questions/208831/can-vector-layer-get-start-point-and-end-point-of-line-using-pyqgis
                    geom2 = QgsGeometry.fromPolyline([point1, point2])
                    pipe.setGeometry(geom2)
                    #pipe_lyr.dataProvider().changeGeometryValues({pipe_id : geom2})
                    pipe_lyr.updateFeature(pipe) 
                     
            pipe_lyr.updateExtents()               
            pipe_lyr.commitChanges()
            pipe_lyr.triggerRepaint() 
            self.dlg.label_ElevOtherEnd.setText(str(z_other_end))
            self.dlg.label_ElevThisEnd.setText(str(z_this_end))
            self.dlg.label_PipeStatus.setText(self.currPipe['status'])
            date_now = time.localtime(time.time())
            update = (str(date_now[0]) + "_" + str(date_now[1]) + "_" + str(date_now[2]) + "_" + str(date_now[3]) + "_" + str(date_now[4]))
            self.dlg.label_Date_pipe.setText(update)
                                    
            #**********************EDIT THE LINE***********Only update the line stuff that needs it.****************************************  
            self.popMsg('Made it to the EDIT PIPE')
            
            
        else:
            self.popMsg(str(self.dlg.lineEdit_YourName.text() + ' Pipe does not exist for edit'))

    def add_Pipe(self):
        sump = str(self.currStruct['SUMPDIST'])
        if sump.replace('.','').isdigit():
            pass
        else:
            self.popMsg("Sump distance for structure not saved.")
            return
        connecto = str(self.dlg.lineEdit_Connecto.text())
        curr_Struct = str(self.currStruct["NUMBER"])
        self.set_draintype()
        pipe_angl = 0.0
        z_other_end = 0.0
        if 'stub' in connecto.lower():
            self.currPipe['stub_ang'] = self.dlg.lineEdit_StubAngle.text()
            if self.dlg.lineEdit_StubAngle.text().isdigit():
                connecto = 'stub'
                pipe_angl = float(int(self.dlg.lineEdit_StubAngle.text()))
            else:
                self.popMsg('Need angle for stub.  NO Decimal point (0 to 360) North' )            
                return
        else:
            pipe_angl = 360.0

        if len(self.pipe_conn_list) < 1:
            self.checkConnect()
        if self.dlg.lineEdit_VertDown.text() == "":
            
            popMsg(str(self.dlg.lineEdit_YourName.text() + ' Input a measurment to the bottom of the pipe first.'))
            return
        else:
            vert_down = float(self.dlg.lineEdit_VertDown.text())

        material = self.dlg.combo_PipeMaterial.currentText()
        diam = float(self.dlg.lineEdit_Diameter.text())
        pipe_lyr = QgsProject.instance().mapLayersByName(self.pipe_layer)[0]
        data_prov_pipe = pipe_lyr.dataProvider()
        struct_layer = QgsProject.instance().mapLayersByName(self.struct_layer)[0]
        if not pipe_lyr.isValid():
            raise Exception('Layer is not valid')

        pipes = pipe_lyr.getFeatures()
        pipe_check = False
        for pipe in pipes:
            msgBox = QMessageBox()
            msgBox.setText(str(self.dlg.lineEdit_YourName.text() + ' You already have this pipe'))
            if (pipe['start'] == curr_Struct) and (pipe['end'] == connecto):
                pipe_check = True
                msgBox.exec_()
                self.clear_pipeSide
                return
            elif (pipe['end'] == curr_Struct) and (pipe['start'] == connecto):
                pipe_check = True
                msgBox.exec_()
                self.clear_pipeSide
                return
        if pipe_check == False: 
            self.currPipe['ellipwidth'] = str(self.dlg.lineEdit_Ellipse.text())
            self.currPipe['stub_ang'] = str(self.dlg.lineEdit_StubAngle.text())
            self.currPipe['start'] = self.currStruct['NUMBER']
            self.currPipe['material'] = self.dlg.combo_PipeMaterial.currentText()

            self.dlg.combo_PipeList.clear()
            self.dlg.listWidget_PipeDescr.clear()
            pipe_name = str(curr_Struct + "_"+ connecto)
            #Make a new feature in Pipe Layer               
            self.pipe_conn_list.append(pipe_name)
            pipe_descrp = str(pipe_name) + "_"+ str(diam) + "_" + material
            self.pipe_descr_list.append(pipe_descrp)
            self.dlg.combo_PipeList.addItems(self.pipe_conn_list)
            self.dlg.listWidget_PipeDescr.addItems(self.pipe_descr_list)

            x_this = float(self.dlg.lineEdit_StructX.text())
            y_this = float(self.dlg.lineEdit_StructY.text())
            z_cent_pipe = float(self.dlg.lineEdit_StructElev.text()) -vert_down + (diam/24)
            point1 = QgsPoint(x_this, y_this, z_cent_pipe)
            if connecto == 'stub':
                x_other_end = x_this + (20.5 * math.sin(6.2832 * (pipe_angl/360)))
                y_other_end = y_this + (20.5 * math.cos(6.2832 * (pipe_angl/360)))
                z_other_end = z_cent_pipe
                point2 = QgsPoint(x_other_end, y_other_end, z_cent_pipe)
                self.currPipe['status'] = "Complete"
                self.currPipe['invt_end'] = 'stub'
            else:
                self.currPipe['status'] = "Incomplete"
                self.currPipe['invt_end'] = '0.0'
                struct_list = struct_layer.getFeatures()
                for struct in struct_list:
                    if struct['NUMBER'] == connecto:
                        x_other_end = float(struct.geometry().get().x())
                        y_other_end = float(struct.geometry().get().y())
                        z_other_end = 0.0
                        
                        point2 = QgsPoint(x_other_end, y_other_end, 0.0)

            date_now = time.localtime(time.time())
            self.dlg.label_ElevThisEnd.setText(str(z_cent_pipe))
            self.dlg.label_ElevOtherEnd.setText(str(z_other_end))
            update = (str(date_now[0]) + "_" + str(date_now[1]) + "_" + str(date_now[2]) + "_" + str(date_now[3]) + "_" + str(date_now[4]))
            self.dlg.label_Date_pipe.setText(update)
            self.currPipe['name'] = pipe_name
            
            self.currPipe['diameter'] = str(diam)
            self.dlg.label_PipeStatus.setText(self.currPipe['status'])
            self.dlg.label_Drain.setText(self.currPipe['drain'])
            #**********************BUILD THE LINE*****************************************************************
            line_this = QgsFeature()
            fields = pipe_lyr.fields()
            line_this.setFields(fields)
            line_this.setGeometry(QgsGeometry.fromPolyline([point1, point2]))
            line_this["name"] = pipe_name
            line_this["jobnum"] = self.currPipe['jobnum']
            line_this['invt_start'] = str(vert_down)
            line_this['invt_end'] = '0.0'
            line_this["material"] = material
            line_this["start"] = self.currPipe['start']
            line_this["end"] = connecto
            line_this["update"] = str(time.time())
            line_this["yourname"] = self.currPipe['yourname']
            line_this["status"] = self.currPipe['status']
            line_this["diameter"] = self.currPipe['diameter']
            line_this["ellipwidth"] = self.currPipe['ellipwidth']
            line_this["stub_ang"] = self.currPipe['stub_ang']
            line_this["drain"] = self.currPipe['drain']
            
            data_prov_pipe.addFeatures([line_this])    
            pipe_lyr.updateExtents()      
            
            pipe_lyr.commitChanges()
    
    def layer_properties(self):#***********************************   NOT WORKING YET ****************************************
        self.popMsg('Not working yet')
        return
        #   https://gis.stackexchange.com/questions/160323/set-color-to-polygons
        layer_settings  = QgsPalLayerSettings()
        text_format = QgsTextFormat()

        text_format.setFont(QFont("Arial", 12))
        text_format.setSize(12)

        buffer_settings = QgsTextBufferSettings()
        buffer_settings.setEnabled(True)
        buffer_settings.setSize(1)
        buffer_settings.setColor(QColor("white"))

        text_format.setBuffer(buffer_settings)
        layer_settings.setFormat(text_format)

        layer_settings.fieldName = "NUMBER"
        layer_settings.placement = 2
        layer_settings.enabled = True

        layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
        my_layer.setLabelsEnabled(True)
        my_layer.setLabeling(layer_settings)
        my_layer.triggerRepaint()


    def add_fields_structure(self):

        layer = self.iface.activeLayer()
        layer_provider = layer.dataProvider()
        layer_provider.addAttributes([QgsField("YOURNAME",QVariant.String)])
        layer_provider.addAttributes([QgsField("SUMPDIST",QVariant.String)])
        
        layer_provider.addAttributes([QgsField("UPDATE",QVariant.String)])
        layer_provider.addAttributes([QgsField("LID",QVariant.String)])
        layer_provider.addAttributes([QgsField("NOTES",QVariant.String)])
        layer.updateFields()

    def add_fields_pipe(self):

        layer = self.iface.activeLayer()
        layer_provider = layer.dataProvider()
        layer_provider.addAttributes([QgsField("name",QVariant.String)])
        layer_provider.addAttributes([QgsField("jobnum",QVariant.String)])
        layer_provider.addAttributes([QgsField('invt_start',QVariant.String)]) 
        layer_provider.addAttributes([QgsField('invt_end',QVariant.String)])        
        layer_provider.addAttributes([QgsField("material",QVariant.String)])
        layer_provider.addAttributes([QgsField("start",QVariant.String)])
        layer_provider.addAttributes([QgsField("end",QVariant.String)])
        layer_provider.addAttributes([QgsField("update",QVariant.String)])
        layer_provider.addAttributes([QgsField("yourname",QVariant.String)])
        layer_provider.addAttributes([QgsField("status",QVariant.String)])
        layer_provider.addAttributes([QgsField("diameter",QVariant.String)])
        layer_provider.addAttributes([QgsField("ellipwidth",QVariant.String)])
        layer_provider.addAttributes([QgsField("stub_ang",QVariant.String)])
       
        layer.updateFields()

    def activestruct(self):
        #Make sure you have selection tool on
        
        layer = self.iface.activeLayer()
        layer.setLabelsEnabled(True)
        
        if len(layer)<1:
            self.popMsg("You must choose the selection tool and active layer")
            return
        
        if len(layer.selectedFeatures())<1:
        
            self.popMsg("You must choose the selection tool and existing structure")
            return
        selection = layer.selectedFeatures()[0]
        #if myItem not in list:
        geom = selection.geometry()
        XYpoint = geom.asPoint()
        selecX = str(geom.get().x())
        selecY = str(geom.get().y())
        selecZ = str(geom.get().z())  #remember to geom.get().setZ(xxxx) on SAVE
        
        Code = str(selection['CODE'])
        SNum = str(selection['NUMBER'])
        jobnum = str(selection['JOBNUM'])
        yourName = str(selection['YOURNAME'])
        SumpD = str(selection['SUMPDIST'])
         
        uDate = str(selection['UPDATE'])
        Lid = str(selection['LID'])
       
        if uDate == "NULL":
            uDate = "Today"

        
        self.dlg.label_StructType.setText(Code) #label_StructType
        self.dlg.lineEdit_StructX.setText(selecX)
        self.dlg.lineEdit_StructY.setText(selecY)
        self.dlg.lineEdit_StructElev.setText(selecZ)
        self.dlg.lineEdit_StructNumb.setText(SNum)
        self.dlg.label_StructDisp.setText(SNum)
        self.dlg.lineEdit_DistDown.setText(SumpD)
        self.dlg.label_Date.setText(uDate)
        self.dlg.label_LidType.setText(Lid)
        self.dlg.textEdit_Notes.setText(str(selection['NOTES']))
        
        
        index = self.dlg.combo_Lid.findText(Lid, QtCore.Qt.MatchFixedString)  #Why does this not work ???**********************************************
        if index >= 0:
            self.dlg.combo_Lid.setCurrentIndex(index)
        index = self.dlg.combo_StructType.findText(Code, QtCore.Qt.MatchFixedString)
        if index >= 0:
            self.dlg.combo_Lid.setCurrentIndex(index)
        
        
        self.currStruct['CODE'] = Code
        self.currStruct['NUMBER'] = SNum
        self.currStruct['JOBNUM'] = jobnum
        self.currStruct['YOURNAME'] = yourName
        self.currStruct['SUMPDIST'] = SumpD
       
        self.currStruct['UPDATE'] = uDate
        self.currStruct['LID'] = Lid
        self.currStruct['NOTES'] = str(selection['NOTES'])

        self.currPipe['jobnum'] = jobnum
        self.currPipe['yourname'] = self.dlg.lineEdit_YourName.text()
        self.get_layers()
        self.get_conn_pipes()
        layer.triggerRepaint()

        #Add more attributes and do a verification that they exist.
    def get_layers(self):
        jobnum = self.currStruct['JOBNUM']
        layerList = self.iface.mapCanvas().layers()
        for layer in layerList:
            name = layer.name()
            splitter = name.split('_')
            if (splitter[0] == jobnum ) and (splitter[1] == "PIPES"):
                self.pipe_layer = name
            elif (splitter[0] == jobnum ) and (splitter[1] != "PIPES"):
                self.struct_layer = name
        msgBox = QMessageBox()
        msgBox.setText(self.struct_layer + " " + self.pipe_layer) #Temp
        msgBox.exec_()
    
    def get_jobinfo(self):
        layerList = self.iface.mapCanvas().layers()
        try:
            if len(layerList) < 1:
                self.popMsg('Layerlist not available')
                return
            strx_exist = bool(False)
            pipe_exist = bool(False)
            for layer in layerList:
                name = layer.name()
                splitter = name.split('_')
                if len(splitter)<2:
                    pass
                elif splitter[1] == "PIPES":
                    self.pipe_layer = name
                    self.job_Number = splitter[0]
                    pipe_exist = True
                elif ('Structures' in splitter) and splitter[1] != "PIPES":
                    self.struct_layer = name
                    strx_exist = True
                else:
                    pass
            if pipe_exist == False:
                self.popMsg('Missing PIPES layer')
                return
            elif pipe_exist == False:
                self.popMsg('Missing PIPES layer load the project')
            self.dlg.label_JobDisp.setText(self.job_Number)
            

        except:
            self.popMsg('Layerlist exception in get_jobinfo')
            return

        
    def check_req_struct(self) :
        good_struct = False
        self.currStruct['JOBNUM'] = self.job_Number
            
        if self.dlg.label_StructDisp.text() != self.currStruct['NUMBER']:
            msg_text = 'Check STRUCTURE Number ' + self.dlg.label_StructDisp.text()
        elif (self.dlg.lineEdit_DistDown.text() == "NULL") or (self.dlg.lineEdit_DistDown.text() == ""):
            msg_text = 'Check sump distance ' + self.dlg.lineEdit_DistDown.text()
        elif len(self.dlg.lineEdit_YourName.text()) < 3:
            msg_text = 'Your Name not long enough.'
        else:
            msg_text = 'Good'
        if msg_text != 'Good':
            good_struct = False
            msgBox = QMessageBox()
            msgBox.setText(msg_text)#Temp
            msgBox.exec_()
        else:
            good_struct = True
            pass
        return(good_struct)  

    def save_struct(self):                
        try:            
            # create structure insert from JOB, StructNum, Type, X_pos,
            if self.check_req_struct():      
                
                str_layr = QgsProject.instance().mapLayersByName(self.struct_layer)[0] 
                str_layr.setLabelsEnabled(True)
                 
                data_prov_struc = str_layr.dataProvider() 
                                
                self.currStruct['CODE'] = self.dlg.label_StructType.text() #Code is Structure Type
                self.currStruct['NUMBER'] = self.dlg.label_StructDisp.text()
                self.currStruct['JOBNUM'] = self.dlg.label_JobDisp.text()
                self.currStruct['YOURNAME'] = self.dlg.lineEdit_YourName.text()
                self.currStruct['SUMPDIST'] = self.dlg.lineEdit_DistDown.text()
            
                self.currStruct['UPDATE'] = str(time.time())
                self.currStruct['LID'] = self.dlg.combo_Lid.currentText() 
                self.currStruct['NOTES'] = self.dlg.textEdit_Notes.toPlainText()

                date_now = date_now = time.localtime(time.time())
                now_time = (str(date_now[0]) + "_" + str(date_now[1]) + "_" + str(date_now[2]) + "_" + str(date_now[3]) + "_" + str(date_now[4]))
                self.dlg.label_Date.setText(now_time)

                str_layr.startEditing()
                for Struct_id in str_layr.getFeatures():
                    if Struct_id['NUMBER'] == self.currStruct['NUMBER']:
                        Struct_id['CODE'] = self.currStruct['CODE']
                        Struct_id['JOBNUM'] = self.currStruct['JOBNUM']
                        Struct_id['SUMPDIST'] = self.currStruct['SUMPDIST']
                        
                        Struct_id['UPDATE'] = self.currStruct['UPDATE']
                        Struct_id['YOURNAME'] = self.currStruct['YOURNAME']
                        Struct_id['LID'] = self.currStruct['LID']
                        Struct_id['NOTES'] = self.currStruct['NOTES']
                        
                        outMsg = str('Sump = ' + Struct_id['SUMPDIST'])
                        if self.dlg.radioButt_XYZ.isChecked():
                            x_pos = float(self.dlg.lineEdit_StructX.text())  #change the geometry of the feature also.
                            y_pos = float(self.dlg.lineEdit_StructY.text())
                            z_pos = float(self.dlg.lineEdit_StructElev.text()) 
                        
                            geom = Struct_id.geometry()
                            geom.get().setX(x_pos)
                            geom.get().setY(y_pos)
                            geom.get().setZ(z_pos)
                            Struct_id.setGeometry(geom)
                                        
                        str_layr.updateFeature(Struct_id) 
                        str_layr.commitChanges()
                        break

                str_layr.triggerRepaint() 
                msgBox = QMessageBox()
                msgBox.setText("Saved to shape file" + outMsg) #Temp
                msgBox.exec_()
                
            else:
                return
            
        except Error as e:
            self.popMsg(str(e) + "\n Failed to save structure. save_struct() \n" + str(self.db_file) )
            
    def changeCode(self):
        self.dlg.label_StructType.setText(self.dlg.combo_StructType.currentText())
    
    def changeLid(self):
        self.dlg.label_LidType.setText(self.dlg.combo_Lid.currentText())  # Define Openfile Dialog
    
        
    def selectFile(self):
        """Open the XXXX.db file locally in directory - should contain the job number""" 

        openfile = QFileDialog.getOpenFileName(None, "Open Data", "", "SQlite db (*.db)")           
        self.dlg.label_LocalDB.setText(openfile[0])
        self.db_file = Path(openfile[0])
        
    # Define Test Connection button function
   

    def set_StructNumber(self):
        
        self.currStruct['JOBNUM'] = self.dlg.lineEdit_StructNumb.text()
        struct_Number = str(self.dlg.lineEdit_StructNumb.text())            
        self.dlg.label_StructDisp.setText(struct_Number)
        if self.currPipe['NUMBER'] =='0000':
            self.currPipe['NUMBER'] = struct_Number + "_XXXXX"
        
    def name_check(self):
        """Open the structure create window"""
        if self.job_Number == 'NULL':
            self.get_jobinfo()    
            self.popMsg("Please select active structure layer.")
            return
        else:
            self.dlg.label_JobDisp.setText(self.job_Number)
            

        if self.dlg.lineEdit_StructNumb.text() == 'XXXXX':
            self.dlg.label_StructDisp.setText('Invalid')            
        else:
            struct_Number = self.dlg.lineEdit_StructNumb.text()
            self.dlg.label_StructDisp.setText(struct_Number) 
    
    

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginDatabaseMenu(
                self.tr(u'&SSI Inverts'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def popMsg(self,text):
        msgBox = QMessageBox()
        msgBox.setText(text)
        msgBox.exec_()

    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.get_jobinfo()
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:                
            # a reference to our map canvas 
            canvas = iface.mapCanvas() 